CREATE TABLE IF NOT EXISTS wallet_blind (
    userid TEXT PRIMARY KEY,
    wallet_address TEXT NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT wallet_address_check CHECK (LENGTH(wallet_address) = 42)
);

-- Giveaways table
create table giveaways (
  id uuid default uuid_generate_v4() primary key,
  message_id text not null,
  channel_id text not null,
  end_time timestamp with time zone not null,
  winners_count integer not null,
  status text default 'active',
  created_at timestamp with time zone default now()
);

-- Giveaway participants table
create table giveaway_participants (
  id uuid default uuid_generate_v4() primary key,
  giveaway_id uuid references giveaways(id),
  user_id text not null,
  wallet_address text not null,
  created_at timestamp with time zone default now(),
  unique(giveaway_id, user_id)
);

create table giveaway_winners (
    id uuid default uuid_generate_v4() primary key,
    giveaway_id uuid references giveaways(id),
    user_id text not null,
    wallet_address text not null,  -- Set to not null since wallet_address is required in participants table
    timestamp timestamptz default now()
);


-- Table: shared_tweets
-- Purpose: Store information about shared tweets from users
create table shared_tweets (
    id bigint generated by default as identity primary key,
    user_id text not null,
    tweet_url text not null,
    wallet_address text not null,
    shared_at timestamp with time zone not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add indexes for better query performance
create index idx_shared_tweets_user_id on shared_tweets(user_id);
create index idx_shared_tweets_wallet_address on shared_tweets(wallet_address);

create table gm_records (
    user_id text primary key,
    username text,
    gm_count integer default 0,
    last_gm_at timestamp with time zone,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index idx_gm_records_username on gm_records(username);


-- Function to increment GM count for a user
-- Returns the updated GM count after increment
create or replace function increment_gm_count(p_user_id text, p_username text)
returns table (gm_count bigint) as $$
begin
    return query
    insert into gm_records (user_id, username, gm_count, last_gm_at)
    values (p_user_id, p_username, 1, now())
    on conflict (user_id) 
    do update set 
        username = p_username,
        gm_count = gm_records.gm_count + 1,
        last_gm_at = now()
    returning gm_count;  -- Return the updated count
end;
$$ language plpgsql;


create table user_feedback (
    id serial primary key,
    user_id text not null,
    username text not null,
    content text not null,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

create index idx_user_feedback_user_id on user_feedback(user_id);


CREATE TABLE system_settings (
    id SERIAL PRIMARY KEY,
    key VARCHAR(255) UNIQUE NOT NULL,
    value TEXT NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE IF NOT EXISTS boost_participants (
    recipient TEXT PRIMARY KEY,
    boost_completed_count INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);


CREATE OR REPLACE FUNCTION public.get_boost_participants()
RETURNS TABLE (
    wallet text,
    user_id text,
    boost_completed_count integer
) 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        wb.wallet,
        wb.user_id,
        bp.boost_completed_count
    FROM wallet_blind wb
    INNER JOIN boost_participants bp 
        ON LOWER(wb.wallet) = LOWER(bp.recipient)
    WHERE bp.boost_completed_count > 0
    ORDER BY bp.boost_completed_count DESC;
END;
$$;